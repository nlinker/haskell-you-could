module Step2 where

-- скрываем стандартные определения, чтобы они нам мне мешали компилировать код
import Prelude hiding (Show, (==))

-- # Про классы типов

-- классы типов — это совсем не то же самое, что классы в Джаве
-- можно использовать синоним "обобщённый интерфейс"
-- 1. определяют только абстрактный интерфейс
-- 2. позволяют создавать несколько независимых реализаций интерфейса

-- обычно функции определяются так
elem1 x []     = False
elem1 x (y:ys) = x==y || (elem1 x ys)

-- случаи можно разбирать и выражением case ... of
-- выбор в данном случае - дело вкуса, на работу кода не влияет
elem2 x xs =
  case xs of
    []     -> False
    (y:ys) -> x==y || (elem2 x ys)

-- попробуйте раскомментировать этот код (подсказка: будет ошибка)
-- test1 = elem1 1 [1,2,3]

class Show a where
  show :: a -> String

instance Show Bool where
  show True = "True"
  show False = "False"


-- Какой тип должен быть у elem? Ну ясно, что `a->[a]->Bool`
-- но тогда и `(==)::a->a->Bool`
-- возникают 2 проблемы:
-- 1. Определён ли (==) вообще для всех типов?
-- 2. (==) должен быть по-разному определён для например Int и [a]
-- 3. Значения не знают, какие операции над ними будут совершать!

class Eq a where
  (==) :: a -> a -> Bool

-- ограничение на тип-параметр
-- (==) :: (Eq a) => a -> a -> Bool
-- elem :: (Eq a) => a -> [a] -> Bool


-- представим, что уже определены функции `integerEq` и `floatEq`
-- тогда можно было бы написать
-- instance Eq Integer where
--  x == y = x `integerEq` y

-- instance Eq Float where
--  x == y =  x `floatEq` y
